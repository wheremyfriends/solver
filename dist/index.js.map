{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/solver.ts"],"sourcesContent":["import { Solver } from \"./solver\";\nimport { Config, NUSModsLessons, TS } from \"./types\";\nimport { preprocess, postprocess, timeToIndex } from \"./utils\";\n\nconst defaultConf = {\n  maxSols: -1,\n  prefDays: [],\n  breaks: [],\n  maxDist: -1,\n  venueInfo: {},\n};\n\nfunction preprocessConfig(config: Config) {\n  return {\n    ...config,\n    breaks: config.breaks.map((b) => {\n      return {\n        ...b,\n        timeslots: b.timeslots.map((ts) => {\n          return {\n            start: timeToIndex(ts.start),\n            end: timeToIndex(ts.end),\n          };\n        }),\n      };\n    }),\n  };\n}\n\nexport function getOptimisedTimetable(\n  timetables: NUSModsLessons[][],\n  index: number,\n  config: Config = defaultConf,\n) {\n  const processedTimetable: TS[][] = timetables.map((e) => {\n    return preprocess(e, config.venueInfo);\n  });\n\n  config = preprocessConfig(config);\n\n  const solver = new Solver(config);\n  const solvedTimetable = solver.solve(processedTimetable, index);\n\n  const ret: NUSModsLessons[][] = [];\n  solvedTimetable.forEach((timetable) => {\n    let retTimetable: any[] = [];\n    timetable.forEach((cls) => {\n      retTimetable = retTimetable.concat(postprocess(cls.timeslots));\n    });\n\n    ret.push(retTimetable);\n  });\n\n  return ret;\n}\n","import { Coord, VenueInfo, TS, NUSModsLessons } from \"./types\";\n\n/**\n * Converts day (e.g Monday/Tuesday/Wednesday) to its corresponding number.\n * 0 - Sunday\n * 1 - Monday\n * etc\n */\nexport function convertDaytoNumber(inp: string): number {\n  const days: { [key: string]: number } = {\n    Sunday: 0,\n    Monday: 1,\n    Tuesday: 2,\n    Wednesday: 3,\n    Thursday: 4,\n    Friday: 5,\n    Saturday: 6,\n  };\n\n  return days[inp];\n}\n\nexport function convertNumbertoDay(inp: number): string {\n  const days: string[] = [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n  ];\n\n  return days[inp];\n}\n\nexport function init2DArr<T>(row: number, col: number, initval: T): T[][] {\n  let output: T[][] = [];\n\n  for (let i = 0; i < row; i++) {\n    output.push(new Array<T>(col).fill(initval));\n  }\n\n  return output;\n}\n\nexport function timeToIndex(time: number) {\n  // Each day is split into half hours\n  // 1 day has 48 half hours\n  const hours = Math.floor(time / 100);\n  const minutes = time % 100;\n\n  return hours * 2 + minutes / 30;\n}\n\n// function indexToTime(timeIndex: number) {\n//   const minuteIndex = timeIndex % 2;\n//   const hours = (timeIndex - minuteIndex) / 2;\n//   const minutes = `${minuteIndex * 30}`.padStart(2, \"0\");\n//\n//   return `${hours}${minutes}`.padStart(4, \"0\");\n// }\n\nexport function preprocess(\n  timeslots: NUSModsLessons[],\n  venueInfo: VenueInfo,\n): TS[] {\n  return timeslots.map((ts) => {\n    // Get coords of venue\n    const coord =\n      ts.venue in venueInfo\n        ? {\n            lat: venueInfo[ts.venue].lat,\n            lon: venueInfo[ts.venue].lon,\n          }\n        : undefined;\n\n    return {\n      ...ts,\n      startIndex: timeToIndex(parseInt(ts[\"startTime\"])),\n      endIndex: timeToIndex(parseInt(ts[\"endTime\"])),\n      dayIndex: convertDaytoNumber(ts[\"day\"]),\n      coord: coord,\n    };\n  });\n}\n\nexport function postprocess(timeslots: TS[]) {\n  return timeslots.map((ts) => {\n    // Remove keys added during preprocessing\n    const { startIndex, endIndex, dayIndex, coord, ...remaining } = ts;\n    return remaining;\n  });\n}\n\nexport function calcDist(p1: Coord, p2: Coord) {\n  const r = 6371; // km\n  const p = Math.PI / 180;\n\n  const a =\n    0.5 -\n    Math.cos((p1.lat - p2.lat) * p) / 2 +\n    (Math.cos(p1.lat * p) *\n      Math.cos(p2.lat * p) *\n      (1 - Math.cos((p2.lon - p1.lon) * p))) /\n      2;\n\n  return 2 * r * Math.asin(Math.sqrt(a)); // in KM\n}\n\nexport function prettify(\n  classes: {\n    moduleCode: string;\n    lessonType: string;\n    classNo: string;\n  }[],\n) {\n  return Object(\n    classes.map((cls) => `${cls.moduleCode} ${cls.lessonType} ${cls.classNo}`),\n  );\n}\n\nexport function transformVenues(venueInfo: {\n  [key: string]: {\n    location: {\n      x: number;\n      y: number;\n    };\n  };\n}): VenueInfo {\n  return Object.keys(venueInfo)\n    .filter((key) => \"location\" in venueInfo[key])\n    .reduce((acc, key) => {\n      acc[key] = {\n        lon: venueInfo[key].location.x,\n        lat: venueInfo[key].location.y,\n      };\n      return acc;\n    }, {} as VenueInfo);\n}\n","import { Break, Cls, Config, Status, TS } from \"./types\";\nimport { init2DArr, calcDist, prettify } from \"./utils\";\nimport { Roarr as log } from \"roarr\";\n\n// Terminologies\n// Module > Lesson > Class > Timeslots\n\nconst HOURS_IN_DAY = 24;\nconst DAYS_IN_WEEK = 7;\nconst TIMESLOT_SIZE = 30; // minutes\n\ntype SimpleTime = {\n  dayIndex: number;\n  startIndex: number;\n  endIndex: number;\n};\nexport function doTimeslotsOverlap(ts1: SimpleTime, ts2: SimpleTime) {\n  // If not on the same day, false for sure\n  if (ts1.dayIndex !== ts2.dayIndex) return false;\n\n  // Returns true if class overlaps timeslot\n  return !(ts1.endIndex <= ts2.startIndex || ts2.endIndex <= ts1.startIndex);\n}\n\n// Check whether the included mod is the cause of the lack of break\nexport function isBreakPresent(isFree: Status[][], cls: Cls, breaks: Break[]) {\n  if (breaks?.length <= 0) return true;\n\n  // Every break needs to be true\n  return breaks.every((b) => {\n    // For each break, there needs at least minDuration consecutive hours\n    const minDuration = b.minDuration;\n    let vacuouslyTrue = true;\n    for (let breakTS of b.timeslots) {\n      const hasOverlap = cls.timeslots.some((classTS) =>\n        doTimeslotsOverlap(\n          {\n            ...breakTS,\n            startIndex: breakTS.start,\n            endIndex: breakTS.end,\n            dayIndex: classTS.dayIndex,\n          },\n          classTS,\n        ),\n      );\n\n      // If the newly inserted timeslot doesn't clash with the breaktime,\n      // then it shouldn't affect\n      if (!hasOverlap) continue;\n      vacuouslyTrue = false;\n\n      Solver.setTimetable(isFree, cls);\n      const res = cls.timeslots.every((ts) => {\n        const dayIndex = ts.dayIndex;\n\n        let totalbreak = 0;\n        for (let i = breakTS.start; i < breakTS.end; i++) {\n          if (isFree[dayIndex][i] !== undefined) totalbreak = 0;\n\n          totalbreak += TIMESLOT_SIZE;\n          if (totalbreak >= minDuration) return true;\n        }\n      });\n      Solver.resetTimetable(isFree, cls);\n\n      return res;\n    }\n\n    return vacuouslyTrue;\n  });\n}\n\nfunction isCloseEnough(isFree: Status[][], cls: Cls, maxDist: number) {\n  if (maxDist < 0) return true;\n\n  return (\n    cls.timeslots\n      .filter((cur) => cur.coord !== undefined)\n      // TODO: Change to use every\n      .reduce((acc, cur) => {\n        const day = cur.dayIndex;\n\n        // Previous\n        // TODO: This might not be -1 given that each block is half hour now\n        const prev = isFree[day][cur.startIndex - 1];\n        if (prev?.coord !== undefined) {\n          const dist = calcDist(prev.coord, cur.coord!);\n          acc &&= dist <= maxDist;\n        }\n\n        // Previous\n        const next = isFree[day][cur.endIndex + 1];\n        if (next?.coord !== undefined) {\n          const dist = calcDist(next.coord, cur.coord!);\n          acc &&= dist <= maxDist;\n        }\n\n        log(`acc: ${acc}`);\n        return acc;\n      }, true)\n  );\n}\n\nexport class Solver {\n  // Keep track of allocation status\n  isFree: Status[][]; // NOTE: One array item represents half hour, instead of one hour, there are 48 half hours a day\n  isLessonAllocated: Map<string, boolean>;\n\n  allClasses: Cls[]; // All classes to consider\n  curClasses: Cls[]; // Working Set\n  result: Cls[][]; // Working Set\n\n  // Additional information to terminate branch early\n  numClassPerLesson: { [key: string]: number };\n\n  // Limit Number of Solutions\n  maxsols: number;\n  numsols: number;\n\n  // Give best solution\n  bestSol: Cls[];\n  minLessonCount: number;\n\n  config: Config;\n\n  constructor(config: Config) {\n    this.numsols = 0;\n    this.maxsols = config.maxSols;\n    this.config = config;\n\n    this.curClasses = [];\n    this.result = [];\n\n    this.isLessonAllocated = new Map();\n    this.isFree = init2DArr<Status>(DAYS_IN_WEEK, HOURS_IN_DAY * 2, undefined);\n\n    this.bestSol = [];\n    this.minLessonCount = 0;\n\n    this.allClasses = [];\n    this.numClassPerLesson = {};\n  }\n\n  static getLessonKey(cls: { moduleCode: string; lessonType: string }) {\n    return `${cls.moduleCode} ${cls.lessonType}`.toLowerCase();\n  }\n\n  static getClassKey(cls: {\n    moduleCode: string;\n    lessonType: string;\n    classNo: string;\n  }) {\n    return `${this.getLessonKey(cls)} ${cls.classNo}`.toLowerCase();\n  }\n\n  static calculatePriority(allClasess: Cls[][]): { [key: string]: number } {\n    const freq: { [key: string]: number } = {};\n    allClasess.forEach((userClasses) => {\n      userClasses.forEach((cls: Cls) => {\n        const key = Solver.getClassKey(cls);\n\n        if (key in freq) freq[key] += 1;\n        else freq[key] = 1;\n      });\n    });\n\n    return freq;\n  }\n\n  static assignPriority(classes: Cls[], priority: { [key: string]: number }) {\n    classes = classes.map((c: Cls) => {\n      const key = Solver.getClassKey(c);\n\n      if (!(key in priority)) return c;\n\n      return { ...c, priority: priority[key] };\n    });\n\n    return classes;\n  }\n\n  static groupIntoClasses(lessons: TS[]) {\n    const classToTimeSlot: { [key: string]: Cls } = {};\n    lessons.forEach((l: TS) => {\n      const key = Solver.getClassKey(l);\n\n      if (key in classToTimeSlot) {\n        classToTimeSlot[key].timeslots.push(l);\n      } else {\n        classToTimeSlot[key] = {\n          moduleCode: l.moduleCode,\n          lessonType: l.lessonType,\n          classNo: l.classNo,\n          priority: 0,\n          coord: l.coord,\n          timeslots: [l],\n        };\n      }\n    });\n\n    const classes = Object.values(classToTimeSlot);\n\n    return classes;\n  }\n\n  static getNumClassPerLesson(classes: Cls[]) {\n    const freq: { [key: string]: number } = {};\n    classes.forEach((c: Cls) => {\n      const key = Solver.getLessonKey(c);\n      if (key in freq) freq[key]++;\n      else freq[key] = 1;\n    });\n\n    return freq;\n  }\n\n  // Optimisation\n  // Preallocate the mods to prevent the need from going one level deeper in\n  // the recursion tree\n  preallocateMods(classes: Cls[]) {\n    let numClassPerLesson = Solver.getNumClassPerLesson(classes);\n\n    classes.forEach((cls: Cls) => {\n      const lessonKey = Solver.getLessonKey(cls);\n\n      const numclasses = numClassPerLesson[lessonKey];\n\n      if (numclasses > 1) return;\n\n      if (!Solver.checkAvail(this.isFree, cls.timeslots)) {\n        return;\n      }\n\n      Solver.setTimetable(this.isFree, cls);\n\n      this.curClasses.push(cls);\n    });\n\n    this.bestSol = structuredClone(this.curClasses);\n\n    // Remove unwanted classes\n    this.allClasses = classes.filter((cls: Cls) => {\n      const lessonKey = Solver.getLessonKey(cls);\n      const numclasses = numClassPerLesson[lessonKey];\n      return numclasses > 1;\n    });\n\n    // Remove unwanted classes\n    this.numClassPerLesson = Object.fromEntries(\n      Object.entries(numClassPerLesson).filter(([_, value]) => {\n        return value > 1;\n      }),\n    );\n  }\n\n  static resetTimetable(isFree: Status[][], cls: Cls) {\n    cls.timeslots.forEach((ts: TS) => {\n      Solver.setTimetableVal(isFree, ts, undefined);\n    });\n  }\n\n  static setTimetable(isFree: Status[][], cls: Cls) {\n    cls.timeslots.forEach((ts: TS) => {\n      Solver.setTimetableVal(isFree, ts, cls);\n    });\n  }\n\n  static setTimetableVal(\n    bitmap: Status[][],\n    timeslot: TS,\n    val: Cls | undefined,\n  ) {\n    for (let i = timeslot.startIndex; i < timeslot.endIndex; i++) {\n      bitmap[timeslot.dayIndex][i] = val;\n    }\n  }\n\n  static checkAvail(bitmap: Status[][], timeslots: TS[]) {\n    for (let ts of timeslots) {\n      for (let i = ts.startIndex; i < ts.endIndex; i++) {\n        if (bitmap[ts.dayIndex][i] != undefined) return false;\n      }\n    }\n    return true;\n  }\n\n  solve(input: TS[][], index: number) {\n    const allUsersClasses = input.map((lessons) =>\n      Solver.groupIntoClasses(lessons),\n    );\n\n    // Find \"priority\" of each lesson slot\n    const coursePriority = Solver.calculatePriority(allUsersClasses);\n\n    const allClasses = Solver.assignPriority(\n      allUsersClasses[index],\n      coursePriority,\n    );\n\n    // Preprocess timetable\n    this.preallocateMods(allClasses);\n\n    // Days preference\n    // Map day to its \"rank\"\n    const daysRank = this.config.prefDays.reduce((acc, day, index) => {\n      acc[day % DAYS_IN_WEEK] = index; // Sunday is both 7 and 0\n      return acc;\n    }, new Array(DAYS_IN_WEEK).fill(DAYS_IN_WEEK));\n\n    log(Object(daysRank), \"daysRank\");\n\n    // Sort to guarantee predictability\n    this.allClasses.sort((a: Cls, b: Cls) => {\n      const aDay = a.timeslots.reduce(\n        (acc, ts) => Math.min(daysRank[ts.dayIndex], acc),\n        DAYS_IN_WEEK,\n      );\n      const bDay = b.timeslots.reduce(\n        (acc, ts) => Math.min(daysRank[ts.dayIndex], acc),\n        DAYS_IN_WEEK,\n      );\n\n      return (\n        b.priority - a.priority ||\n        aDay - bDay ||\n        b.moduleCode.localeCompare(a.moduleCode) ||\n        b.lessonType.localeCompare(a.lessonType) ||\n        b.classNo.localeCompare(a.classNo)\n      );\n    });\n\n    log(prettify(this.curClasses), \"this.curClasses\");\n    log(prettify(this.allClasses), \"this.allClasses\");\n    log(this.numClassPerLesson, \"this.numClassPerLesson\");\n\n    const numlessons = Object.keys(this.numClassPerLesson).length;\n    this.minLessonCount = numlessons;\n    this._solve(0, numlessons);\n\n    log(Object(this.result.map((classes) => prettify(classes))), \"this.result\");\n    if (this.result.length <= 0) return [this.bestSol];\n\n    return this.result;\n  }\n\n  _solve(counter: number, numlessons: number): void {\n    // Save \"best\" result\n    if (numlessons < this.minLessonCount) {\n      this.minLessonCount = numlessons;\n      this.bestSol = structuredClone(this.curClasses);\n    }\n\n    if (this.maxsols > 0 && this.numsols >= this.maxsols) {\n      return;\n    }\n\n    if (numlessons <= 0) {\n      this.numsols++;\n\n      // Save solution\n      log(prettify(this.curClasses), \"Solution\");\n      // Deep Copy for minimal confusion\n      const solution = structuredClone(this.curClasses);\n      // const solution = this.curClasses;\n      this.result.push(solution);\n      return;\n    }\n\n    if (counter == this.allClasses.length) {\n      // Base Case\n      // guarantees algorithm terminate\n      return;\n    }\n    const curCls = this.allClasses[counter];\n    const lessonKey = Solver.getLessonKey(curCls);\n\n    this.numClassPerLesson[lessonKey]--;\n\n    // For every mod, make the decision to choose or don't choose\n    // Choice 1: Pick\n    const isAvail = Solver.checkAvail(this.isFree, curCls.timeslots);\n    const isAllocated: boolean = !!this.isLessonAllocated.get(lessonKey);\n    const isClose: boolean = isCloseEnough(\n      this.isFree,\n      curCls,\n      this.config.maxDist,\n    );\n    const hasBreak: boolean = isBreakPresent(\n      this.isFree,\n      curCls,\n      this.config.breaks,\n    );\n\n    // console.log({ curCls, isAvail, isAllocated, isClose, hasBreak });\n\n    if (isAvail && !isAllocated && isClose && hasBreak) {\n      Solver.setTimetable(this.isFree, curCls);\n      this.isLessonAllocated.set(lessonKey, true);\n      this.curClasses.push(curCls);\n\n      this._solve(counter + 1, numlessons - 1);\n\n      Solver.resetTimetable(this.isFree, curCls);\n      this.isLessonAllocated.set(lessonKey, false);\n      this.curClasses.pop();\n    }\n\n    // Choice 2: Don't pick\n    this._solve(counter + 1, numlessons);\n\n    this.numClassPerLesson[lessonKey]++;\n  }\n}\n"],"mappings":"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","names":["log","index"]}