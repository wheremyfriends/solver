{"version":3,"sources":["../src/utils.ts","../src/solver.ts","../src/index.ts"],"sourcesContent":["import { TimeSlot, TS } from \"./solver\";\n\n/**\n * Converts day (e.g Monday/Tuesday/Wednesday) to its corresponding number.\n * 0 - Sunday\n * 1 - Monday\n * etc\n */\nexport function convertDaytoNumber(inp: string): number {\n  const days: { [key: string]: number } = {\n    Sunday: 0,\n    Monday: 1,\n    Tuesday: 2,\n    Wednesday: 3,\n    Thursday: 4,\n    Friday: 5,\n    Saturday: 6,\n  };\n\n  return days[inp];\n}\n\nexport function convertNumbertoDay(inp: number): string {\n  const days: string[] = [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n  ];\n\n  return days[inp];\n}\n\nexport function init2DArr<T>(row: number, col: number, initval: T): T[][] {\n  let output: T[][] = [];\n\n  for (let i = 0; i < row; i++) {\n    output.push(new Array<T>(col).fill(initval));\n  }\n\n  return output;\n}\n\nexport function preprocess(timeslots: TimeSlot[]) {\n  return timeslots.map((ts) => {\n    return {\n      ...ts,\n      startTime: parseInt(ts[\"startTime\"]) / 100,\n      endTime: parseInt(ts[\"endTime\"]) / 100,\n      day: convertDaytoNumber(ts[\"day\"]),\n    };\n  });\n}\n\nexport function postprocess(timeslots: TS[]) {\n  return timeslots.map((ts) => {\n    return {\n      ...ts,\n      startTime: (ts[\"startTime\"] * 100).toString().padStart(4, \"0\"),\n      endTime: (ts[\"endTime\"] * 100).toString().padStart(4, \"0\"),\n      day: convertNumbertoDay(ts[\"day\"]),\n    };\n  });\n}\n","import { init2DArr } from \"./utils\";\nimport { Roarr as log } from \"roarr\";\n\n// Terminologies\n// Module > Lesson > Class > Timeslots\n\nconst HOURS_IN_DAY = 24;\nconst DAYS_IN_WEEK = 7;\nconst NO_SOL_ERR_MSG = \"No Solution\";\n\nenum Status {\n  FREE,\n  ALLOCATED,\n}\n\nenum Day {\n  SUNDAY,\n  MONDAY,\n  TUESDAY,\n  WEDNESDAY,\n  THURSDAY,\n  FRIDAY,\n  SATURDAY,\n}\n\ntype Cls = {\n  moduleCode: string;\n  lessonType: string;\n  classNo: string;\n  priority: number;\n  timeslots: TS[];\n};\n\ntype Config = {\n  maxSols: number;\n};\n\n// TS for TimeSlot\nexport type TS = {\n  moduleCode: string;\n  lessonType: string;\n  classNo: string;\n  startTime: number;\n  endTime: number;\n  day: Day;\n  [key: string]: any;\n};\n\nexport type TimeSlot = {\n  moduleCode: string;\n  lessonType: string;\n  classNo: string;\n  startTime: string;\n  endTime: string;\n  day: string;\n  [key: string]: any;\n};\n\nexport class Solver {\n  // Keep track of allocation status\n  isFree: Status[][];\n  isLessonAllocated: Map<string, boolean>;\n\n  allClasses: Cls[]; // All classes to consider\n  curClasses: Cls[]; // Working Set\n  result: Cls[][]; // Working Set\n\n  // Additional information to terminate branch early\n  numClassPerLesson: { [key: string]: number };\n\n  // Limit Number of Solutions\n  maxsols: number;\n  numsols: number;\n\n  // Give best solution\n  bestSol: Cls[];\n  maxcounter: number;\n\n  constructor({ maxSols }: Config) {\n    this.numsols = 0;\n    this.maxsols = maxSols;\n\n    this.curClasses = [];\n    this.result = [];\n\n    this.isLessonAllocated = new Map();\n    this.isFree = init2DArr<Status>(DAYS_IN_WEEK, HOURS_IN_DAY, Status.FREE);\n\n    this.bestSol = [];\n    this.maxcounter = 0;\n\n    this.allClasses = [];\n    this.numClassPerLesson = {};\n  }\n\n  static getLessonKey(cls: { moduleCode: string; lessonType: string }) {\n    return `${cls.moduleCode} ${cls.lessonType}`.toLowerCase();\n  }\n\n  static getClassKey(cls: {\n    moduleCode: string;\n    lessonType: string;\n    classNo: string;\n  }) {\n    return `${this.getLessonKey(cls)} ${cls.classNo}`.toLowerCase();\n  }\n\n  static calculatePriority(allClasess: Cls[][]): { [key: string]: number } {\n    const freq: { [key: string]: number } = {};\n    allClasess.forEach((userClasses) => {\n      userClasses.forEach((cls: Cls) => {\n        const key = Solver.getClassKey(cls);\n\n        if (key in freq) freq[key] += 1;\n        else freq[key] = 1;\n      });\n    });\n\n    return freq;\n  }\n\n  static assignPriority(classes: Cls[], priority: { [key: string]: number }) {\n    classes = classes.map((c: Cls) => {\n      const key = Solver.getClassKey(c);\n\n      if (!(key in priority)) return c;\n\n      return { ...c, priority: priority[key] };\n    });\n\n    return classes;\n  }\n\n  static groupIntoClasses(lessons: any[]) {\n    const classToTimeSlot: { [key: string]: Cls } = {};\n    lessons.forEach((l: TS) => {\n      const key = Solver.getClassKey(l);\n\n      if (key in classToTimeSlot) {\n        classToTimeSlot[key].timeslots.push(l);\n      } else {\n        classToTimeSlot[key] = {\n          moduleCode: l.moduleCode,\n          lessonType: l.lessonType,\n          classNo: l.classNo,\n          priority: 0,\n          timeslots: [l],\n        };\n      }\n    });\n\n    const classes = Object.values(classToTimeSlot);\n\n    return classes;\n  }\n\n  static getNumClassPerLesson(classes: Cls[]) {\n    const freq: { [key: string]: number } = {};\n    classes.forEach((c: Cls) => {\n      const key = Solver.getLessonKey(c);\n      if (key in freq) freq[key]++;\n      else freq[key] = 1;\n    });\n\n    return freq;\n  }\n\n  preallocateMods(classes: Cls[]) {\n    let numClassPerLesson = Solver.getNumClassPerLesson(classes);\n    let haserror = false;\n\n    classes.forEach((cls: Cls) => {\n      const lessonKey = Solver.getLessonKey(cls);\n\n      const numclasses = numClassPerLesson[lessonKey];\n\n      if (numclasses > 1) return;\n\n      if (!Solver.checkAvail(this.isFree, cls.timeslots)) {\n        haserror = true;\n        return;\n      }\n\n      this.setTimetable(cls);\n\n      this.curClasses.push(cls);\n      this.bestSol.push(cls);\n    });\n\n    if (haserror) {\n      throw new Error(\"No sol\");\n    }\n\n    // Remove unwanted classes\n    classes = classes.filter((cls: Cls) => {\n      const lessonKey = Solver.getLessonKey(cls);\n      const numclasses = numClassPerLesson[lessonKey];\n      return numclasses > 1;\n    });\n\n    // Remove unwanted classes\n    numClassPerLesson = Object.fromEntries(\n      Object.entries(numClassPerLesson).filter(([_, value]) => {\n        return value > 1;\n      }),\n    );\n\n    return {\n      numClassPerLesson,\n      classes,\n    };\n  }\n\n  resetTimetable(cls: Cls) {\n    cls.timeslots.forEach((ts: TS) => {\n      Solver.setTimetableVal(this.isFree, ts, Status.FREE);\n    });\n  }\n\n  setTimetable(cls: Cls) {\n    cls.timeslots.forEach((ts: TS) => {\n      Solver.setTimetableVal(this.isFree, ts, Status.ALLOCATED);\n    });\n  }\n\n  static setTimetableVal(bitmap: Status[][], timeslot: TS, val: Status) {\n    for (let i = timeslot.startTime; i < timeslot.endTime; i++) {\n      bitmap[timeslot.day][i] = val;\n    }\n  }\n\n  static checkAvail(bitmap: Status[][], timeslots: TS[]) {\n    for (let ts of timeslots) {\n      for (let i = ts.startTime; i < ts.endTime; i++) {\n        if (bitmap[ts.day][i] == Status.ALLOCATED) return false;\n      }\n    }\n    return true;\n  }\n\n  solve(input: any[][], index: number) {\n    const allUsersClasses = input.map((lessons) =>\n      Solver.groupIntoClasses(lessons),\n    );\n\n    // Find \"priority\" of each lesson slot\n    const coursePriority = Solver.calculatePriority(allUsersClasses);\n\n    const allClasses = Solver.assignPriority(\n      allUsersClasses[index],\n      coursePriority,\n    );\n\n    // Preprocess timetable\n    try {\n      var { classes, numClassPerLesson } = this.preallocateMods(allClasses);\n    } catch (error) {\n      return [this.bestSol];\n    }\n    this.numClassPerLesson = numClassPerLesson;\n    this.allClasses = classes;\n    this.allClasses.sort((a: Cls, b: Cls) => {\n      return (\n        b.priority - a.priority ||\n        b.moduleCode.localeCompare(a.moduleCode) ||\n        b.lessonType.localeCompare(a.lessonType) ||\n        b.classNo.localeCompare(a.classNo)\n      );\n    });\n\n    log(Object(this.allClasses), \"this.allClasses\");\n    log(this.numClassPerLesson, \"this.numClassPerLesson\");\n\n    this._solve(0, Object.keys(this.numClassPerLesson).length);\n\n    log(Object(this.result), \"this.result\");\n    if (this.result.length <= 0) return [this.bestSol];\n\n    return this.result;\n  }\n\n  _solve(counter: number, numlessons: number): void {\n    if (this.maxsols > 0 && this.numsols >= this.maxsols) {\n      return;\n    }\n\n    if (numlessons <= 0) {\n      this.numsols++;\n\n      // Save solution\n      log(Object(this.curClasses), \"Solution\");\n      // Deep Copy for minimal confusion\n      const solution = structuredClone(this.curClasses);\n      // const solution = this.curClasses;\n      this.result.push(solution);\n      return;\n    }\n\n    if (counter == this.allClasses.length) {\n      // Base Case\n      // guarantees algorithm terminate\n      return;\n    }\n    const curCls = this.allClasses[counter];\n    const lessonKey = Solver.getLessonKey(curCls);\n\n    this.numClassPerLesson[lessonKey]--;\n\n    // For every mod, make the decision to choose or don't choose\n    // Choice 1: Pick\n    const isAvail = Solver.checkAvail(this.isFree, curCls.timeslots);\n    const isAllocated: boolean = !!this.isLessonAllocated.get(lessonKey);\n\n    if (isAvail && !isAllocated) {\n      this.setTimetable(curCls);\n      this.isLessonAllocated.set(lessonKey, true);\n      this.curClasses.push(curCls);\n\n      this._solve(counter + 1, numlessons - 1);\n\n      this.resetTimetable(curCls);\n      this.isLessonAllocated.set(lessonKey, false);\n      this.curClasses.pop();\n    }\n\n    // Choice 2: Don't pick\n    this._solve(counter + 1, numlessons);\n\n    this.numClassPerLesson[lessonKey]++;\n  }\n}\n","import { TimeSlot, TS, Solver } from \"./solver\";\nimport { preprocess, postprocess } from \"./utils\";\n\nexport function getOptimisedTimetable(\n  timetables: TimeSlot[][],\n  index: number,\n  maxSols: number = -1,\n) {\n  const processedTimetable: TS[][] = timetables.map((e) => {\n    return preprocess(e);\n  });\n\n  const solver = new Solver({ maxSols });\n  const solvedTimetable = solver.solve(processedTimetable, index);\n\n  const ret: TimeSlot[][] = [];\n  solvedTimetable.forEach((timetable) => {\n    let retTimetable: TimeSlot[] = [];\n    timetable.forEach((cls) => {\n      retTimetable = retTimetable.concat(postprocess(cls.timeslots));\n    });\n\n    ret.push(retTimetable);\n  });\n\n  return ret;\n}\n"],"mappings":"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","names":[]}